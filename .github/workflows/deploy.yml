name: CI/CD for Microservices

on:
  push:
    branches: [ main ]

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      game: ${{ steps.filter.outputs.game }}
      analytics: ${{ steps.filter.outputs.analytics }}
      order: ${{ steps.filter.outputs.order }}
    steps:
      - uses: actions/checkout@v3

      - name: Detect changed services
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            game:
              - 'game-service/**'
            analytics:
              - 'analytics-service/**'
            order:
              - 'order-service/**'

  deploy-game:
    needs: detect-changes
    if: needs.detect-changes.outputs.game == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Docker Login
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build & Push game-service image
        run: |
          IMAGE_TAG=${{ github.sha }}
          cd game-service
          docker build --no-cache -t shalini1772/game-service:$IMAGE_TAG .
          docker push shalini1772/game-service:$IMAGE_TAG

      - name: Configure AWS CLI & kubeconfig
        run: |
          aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
          aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          aws configure set region "${{ secrets.AWS_REGION }}"
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

      - name: Deploy game-service to EKS
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          export KUBECONFIG=$PWD/kubeconfig
          kubectl create namespace game --dry-run=client -o yaml | kubectl apply -f -
          kubectl delete pods -l app=game-service -n game --ignore-not-found
          envsubst < game-service/k8s/game-service-deployment.yaml | kubectl apply -n game -f -
          kubectl apply -f game-service/k8s/mysql-deployment.yaml -n game
          kubectl apply -f game-service/k8s/game-ingress.yaml -n game
          kubectl rollout status deployment/game-service -n game

  deploy-analytics:
    needs: detect-changes
    if: needs.detect-changes.outputs.analytics == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Docker Login
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build & Push analytics-service image
        run: |
          IMAGE_TAG=${{ github.sha }}
          cd analytics-service
          docker build --no-cache -t shalini1772/analytics-service:$IMAGE_TAG .
          docker push shalini1772/analytics-service:$IMAGE_TAG

      - name: Configure AWS CLI & kubeconfig
        run: |
          aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
          aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          aws configure set region "${{ secrets.AWS_REGION }}"
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

      - name: Deploy analytics-service to EKS
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          export KUBECONFIG=$PWD/kubeconfig
          kubectl create namespace analytics --dry-run=client -o yaml | kubectl apply -f -
          kubectl delete pods -l app=analytics-service -n analytics --ignore-not-found
          envsubst < analytics-service/k8s/analytics-service-deployment.yaml | kubectl apply -n analytics -f -
          kubectl apply -f analytics-service/k8s/analytics-ingress.yaml -n analytics
          kubectl rollout status deployment/analytics-service -n analytics

      - name: Debug if rollout fails
        if: failure()
        run: |
          echo "Rollout failed. Logs:"
          kubectl get pods -n analytics
          kubectl logs -l app=analytics-service -n analytics --tail=100 || true

  deploy-order:
    needs: detect-changes
    if: needs.detect-changes.outputs.order == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Docker Login
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build & Push order-service image
        run: |
          IMAGE_TAG=${{ github.sha }}
          cd order-service
          docker build --no-cache -t shalini1772/order-service:$IMAGE_TAG .
          docker push shalini1772/order-service:$IMAGE_TAG

      - name: Configure AWS CLI & kubeconfig
        run: |
          aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
          aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          aws configure set region "${{ secrets.AWS_REGION }}"
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

      - name: Deploy order-service to EKS
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          export KUBECONFIG=$PWD/kubeconfig
          kubectl create namespace order --dry-run=client -o yaml | kubectl apply -f -
          kubectl delete pods -l app=order-service -n order --ignore-not-found
          envsubst < order-service/k8s/order-service-deployment.yaml | kubectl apply -n order -f -
          kubectl apply -f order-service/k8s/mysql-deployment.yaml -n order
          kubectl apply -f order-service/k8s/order-ingress.yaml -n order
          kubectl rollout status deployment/order-service -n order
