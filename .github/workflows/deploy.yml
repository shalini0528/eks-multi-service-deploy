name: CI/CD for Microservices

on:
  push:
    branches: [ main ]

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      game: ${{ steps.filter.outputs.game }}
      analytics: ${{ steps.filter.outputs.analytics }}
      order: ${{ steps.filter.outputs.order }}
    steps:
      - uses: actions/checkout@v3

      - name: Detect which service changed
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            game:
              - 'game-service/**'
            analytics:
              - 'analytics-service/**'
            order:
              - 'order-service/**'

  deploy-template:
    strategy:
      matrix:
        service: [game, analytics, order]
    needs: detect-changes
    if: needs.detect-changes.outputs[matrix.service] == 'true'
    name: Deploy ${{ matrix.service }}-service
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Docker Login
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build & Push Docker Image
        run: |
          IMAGE_TAG=${{ github.sha }}
          docker build -t shalini1772/${{ matrix.service }}-service:$IMAGE_TAG ./${{ matrix.service }}-service
          docker push shalini1772/${{ matrix.service }}-service:$IMAGE_TAG

      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
          aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          aws configure set region "${{ secrets.AWS_REGION }}"

      - name: Setup kubeconfig
        run: |
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig

      - name: Deploy to Kubernetes
        run: |
          export KUBECONFIG=$PWD/kubeconfig
          export IMAGE_TAG=${{ github.sha }}
          NS=${{ matrix.service }}
          
          # Create namespace if not exists
          kubectl create namespace $NS --dry-run=client -o yaml | kubectl apply -f -

          # Delete old pods to ensure new rollout
          kubectl delete pods -l app=${{ matrix.service }}-service -n $NS --ignore-not-found

          # Apply deployment with tag substitution
          envsubst < $NS-service/k8s/$NS-service-deployment.yaml | kubectl apply -n $NS -f -

          # Apply optional MySQL (for game and order)
          if [[ "$NS" == "game" || "$NS" == "order" ]]; then
            kubectl apply -f $NS-service/k8s/mysql-deployment.yaml -n $NS
          fi

          # Apply ingress
          kubectl apply -f $NS-service/k8s/$NS-ingress.yaml -n $NS

          # Wait for rollout
          kubectl rollout status deployment/${{ matrix.service }}-service -n $NS
