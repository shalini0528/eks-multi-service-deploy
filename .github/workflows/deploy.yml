name: CI/CD for Microservices

on:
  push:
    branches: [ main ]

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      game: ${{ steps.filter.outputs.game }}
      analytics: ${{ steps.filter.outputs.analytics }}
      order: ${{ steps.filter.outputs.order }}
    steps:
      - uses: actions/checkout@v3

      - name: Detect which service changed
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            game:
              - 'game-service/**'
            analytics:
              - 'analytics-service/**'
            order:
              - 'order-service/**'

  deploy-services:
    needs: detect-changes
    runs-on: ubuntu-latest
    strategy:
      matrix:
        service: [game, analytics, order]
    if: needs.detect-changes.outputs[matrix.service] == 'true'

    steps:
      - uses: actions/checkout@v3

      - name: Docker Login
        run: echo "${{ secrets.DOCKER_PASSWORD }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin

      - name: Build & Push Docker Image
        run: |
          IMAGE_TAG=${{ github.sha }}
          docker build -t shalini1772/${{ matrix.service }}-service:$IMAGE_TAG ./${{ matrix.service }}-service
          docker push shalini1772/${{ matrix.service }}-service:$IMAGE_TAG

      - name: Configure AWS CLI
        run: |
          aws configure set aws_access_key_id "${{ secrets.AWS_ACCESS_KEY_ID }}"
          aws configure set aws_secret_access_key "${{ secrets.AWS_SECRET_ACCESS_KEY }}"
          aws configure set region "${{ secrets.AWS_REGION }}"

      - name: Setup kubeconfig
        run: |
          echo "${{ secrets.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV

      - name: Deploy to EKS
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          export KUBECONFIG=$PWD/kubeconfig
          NS=${{ matrix.service }}
          DEPLOY_DIR=${NS}-service/k8s

          # Create namespace if not exists
          kubectl create namespace $NS --dry-run=client -o yaml | kubectl apply -f -

          # Clean up old pods to avoid stuck rollouts
          kubectl delete pods -l app=${NS}-service -n $NS --ignore-not-found

          # Apply deployment with image tag substitution
          envsubst < $DEPLOY_DIR/${NS}-service-deployment.yaml | kubectl apply -n $NS -f -

          # Apply MySQL if needed
          if [[ "$NS" == "game" || "$NS" == "order" ]]; then
            kubectl apply -f $DEPLOY_DIR/mysql-deployment.yaml -n $NS
          fi

          # Apply ingress
          kubectl apply -f $DEPLOY_DIR/${NS}-ingress.yaml -n $NS

          # Wait for rollout
          kubectl rollout status deployment/${NS}-service -n $NS
